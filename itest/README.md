## `network_test.pl`

### TL;DR

    # yum install perl-Test-Simple

	$ afina -p pidfile -d
	$ prove .../путь/к/network_test.pl
	$ kill $(cat pidfile)

	$ prove .../network_test.pl :: -r <FIFO, котоую Afina читает> -w <FIFO, в которую Afina пишет>

### Нельзя войти в одну реку более одного раза

Текущая версия парсера не поддерживает команду `delete`, так что тест не может проверить работу команды `add` более одного раза: экземпляр с данным именем останется в процессе навсегда. Поэтому после успешного прохождения теста Afina придётся остановить, второй раз тест она не пройдёт.

### Как работает

Используются только входящие в комплект Perl модули, но на CentOS7 придётся сделать `yum install perl-Test-Simple`.

Тест принимает параметры командной строки:

* `-a` / `--address=127.0.0.1` задаёт адрес, куда подключаться
* `-p` / `--port=8080` задаёт порт
* `-s` / `--silent` уменьшает количество отладочной информации (сетевой обмен данными будет спрятан)
* `-r` / `--rfifo` указывает FIFO, *из* которого Afina будет *читать* команды
* `-w` / `--wfifo` указывает FIFO, *в* который Afina будет *писать* ответы на команды

Если запускать тест при помощи `prove` (рекомендуется: он старается печатать только ошибки и выводит краткую статистику), параметры необходимо отделять `::`. Пример:

    prove ../../afina/itest/network_test.pl :: -a 192.0.2.19 -p 11211

Если запускать тест напрямую при помощи `perl`, двоеточия не нужны. Если TAP-драйвер не позволяет передавать аргументы командной строки, можно назначить переменные окружения `AFINA_SERVER`, `AFINA_PORT`, `AFINA_RFIFO`, `AFINA_WFIFO`.

#### Передача команд через FIFO

Не перепутайте: R и W указаны с точки зрения Афины, а не самого теста. Так сделано, чтобы передавать Афине и тесту похожие или одинаковые аргументы командной строки, а не противоположные по значению.

Некоторые программы, которые пишут в FIFO, по окончании сеанса общения закрывают свой конец pipe'а, чтобы программа-читатель (в нашем случае, тест) получила EOF и вернулась из системного вызова read(). К сожалению, если сделать это слишком рано, записанный в FIFO ответ (см. особенности `O_NONBLOCK|O_RDWR` в `man 7 fifo` на Linux) потеряется, и тестировать самым простым образом (`echo command > rfifo; cat wfifo`) будет невозможно. Тест *не* предполагает, что за ответом на команду последует EOF (но сам корректно закрывает `rfifo`, прежде чем читать). Вместо этого тест *один* раз делает `read` с достаточно большим буфером, чтобы правильный ответ поместился. Если Ваша Афина записывает ответ по частям (`write(fd, "VALUES...", ...); ... write(fd, "END\r\n", ...);` - хотя в неблокирующем режиме так делать неудобно), тест она не пройдёт. Исправления приветствуются.

Передать тесту только `-r <FIFO, откуда Afina читает команды>` *можно*. При этом часть команд (установка значений переменных) будет выполнена через этот FIFO, а другая часть (проверка значений переменных) - через сеть.

### У меня не проходит тесты

Тесты - это код. Код часто содержит ошибки. Ergo, тесты могут содержать ошибки. Тем не менее,

#### Ошибка может быть не только в сетевом слое

Если тест говорит, что должно быть `NOT_STORED`, а Afina вернула `STORED`, дело, скорее всего, в `MapBasedGlobalLockImpl.cpp` или его окрестностях. Убедитесь при помощи отладчика.

#### Начинаем с первого заваленного теста

Некоторые тесты зависимы друг от друга. Например, один тест сначала создаёт запись в базе, затем второй дописывает к ней ещё немного, а третий проверяет, что дописанное значение совпадает с ожидаемым.

#### На чём именно упало?

Разберём пример:

    #   Failed test 'Replace an existent key'
    #   at ../itest/t.pl line 86.
    #          got: 'CLIENT_ERROR Unknown command name
    # '
    #     expected: 'STORED
    # '

Здесь видно название теста ("Replace an existent key"), ожидаемое значение ответа Afina на команду и то, что нам ответили вместо этого. Если из названия теста не понятно, что не так, можно запустить `prove -v ...` (или напрямую `perl .../путь/к/тесту`) и посмотреть на сетевой ввод-вывод:

    ok 45 - Connected to Afina
    ok 46 - Sent request
    # -> replace test 0 0 3
    # -> zzz
    ok 47 - Closed writing end of connection
    # <- CLIENT_ERROR Unknown command name
    not ok 48 - Replace an existent key

Здесь видно, что `CLIENT_ERROR` нам прислали в ответ на команду `replace`. Отсюда уже можно делать выводы.

#### Looks like you planned XX tests but ran YY

Сам набор тестов может выбросить исключение и упасть. Например, так происходит, если `afina` падает, и очередная попытка подключиться к ней не удаётся. При этом оказывается запущено меньше тестов, чем планировалось.
